# bfs

<aside>
💡

"큐에서 빼고 → 주변 넣기 → 방문표시"

</aside>

- bfs 랑 큐
    
     다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘
    
    <img width="586" height="282" alt="Image" src="https://github.com/user-attachments/assets/fa7d0ca1-6e46-4d9d-a169-6c2c09fd5fd2" />

    
    BFS 알고리즘에서는 좌표를 담을 큐가 필요
    
    BFS 알고리즘이 시작되면 우선 (0, 0)에 방문했다는 표시를 남기고 해당 칸을 큐에 넣음
    
    지금 큐의 front는 (0, 0)이고 pop함
    
    그리고 (0, 0)의 상하좌우 칸을 보는데, 이 중에서 우리는 파란색 칸이면서 아직 방문하지 않은 칸을 찾을 것임
    
    <img width="645" height="297" alt="Image" src="https://github.com/user-attachments/assets/29e443e7-35fc-4f66-8dcd-d03776e21635" />

    
    (0, 1)과 (1, 0)은 모두 파란 칸이면서 아직 방문X 
    
    <img width="659" height="307" alt="Image" src="https://github.com/user-attachments/assets/ae3a697e-7b42-421e-b1ae-d306c05a91d8" />

    
    이 2개의 칸에 방문했다는 표시를 남기고 큐에 넣기
    
    <img width="636" height="305" alt="Image" src="https://github.com/user-attachments/assets/76221974-70bc-4b2f-8536-d6145c32a67d" />

    
    큐의 front는 (0, 1)이고 pop함 
    
    <img width="691" height="314" alt="Image" src="https://github.com/user-attachments/assets/43df94f0-30ea-4282-954e-4f2262f33df6" />

    
     (0, 1)의 상하좌우 칸을 확인
    
    이 칸들 중에서 (0, 0)은 파란 칸이지만 이미 방문을 했고 (1, 1)은 빨간 칸임
    
    (0, 2)에 방문했다는 표시를 남기고 큐에 넣기
    
    <img width="1228" height="715" alt="Image" src="https://github.com/user-attachments/assets/db850a92-4ca3-4a40-8140-f2cd539c92fd" />

    
    큐의 front는 (1, 0)이고 pop함 
    
    ….
    
    계속 이런식으로 큐의 front를 pop하고 
    
    인접한 칸 중에서 방문하지 않은 파란색 칸에 표시를 남기고 
    
    큐에 넣어줌
    
- 백준 1926
    
    
    <img width="694" height="322" alt="Image" src="https://github.com/user-attachments/assets/535632a1-420b-4763-8930-8ef4e2766f9d" />

    
    <img width="683" height="312" alt="Image" src="https://github.com/user-attachments/assets/0ab15871-0d84-4f32-a9aa-3c13456c92f6" />
    
    1. 도화지 정보 입력을 위한 ..
    
    ```java
    public class Main {
        static int n, m;
        // 도화지 정보: 1 = 그림(파란 칸), 0 = 빈 칸(빨간 칸)
        static int[][] board = new int[502][502];
        // 방문 여부 체크 배열
        static boolean[][] vis = new boolean[502][502];
        // 네 방향 이동: 하, 우, 상, 좌 (x=행, y=열)
        static int[] dx = {1, 0, -1, 0};
        static int[] dy = {0, 1, 0, -1};
    ```
    
    ```java
      public static void main(String[] args) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            StringTokenizer st;
    
            // 입력: 세로 n, 가로 m
            st = new StringTokenizer(br.readLine());
            n = Integer.parseInt(st.nextToken());
            m = Integer.parseInt(st.nextToken());
    
            // 도화지 정보 입력
            for (int i = 0; i < n; i++) {
                st = new StringTokenizer(br.readLine());
                for (int j = 0; j < m; j++) {
                    board[i][j] = Integer.parseInt(st.nextToken());
                }
            }
    
            int mx = 0;   // 가장 큰 그림의 넓이
            int num = 0;  // 그림 개수
    ```
    
    1. 도화지에 있는 모든 그림을 찾아내기 
    
    전체 도화지를 이중 for문으로 순회한다.
    
    현재 칸이 그림(1)이고, 아직 방문하지 않았다면:
    
    - 그 칸이 새로운 그림의 시작점이므로 BFS를 실행한다.
    - BFS 결과로 그 그림의 넓이를 얻고, 그림 개수를 +1 한다.
    
    이 과정을 도화지 전체에 대해 반복하면 모든 그림을 찾을 수 있다
    
    ```java
     for (int i = 0; i < n; i++) {        // 세로 방향으로
                for (int j = 0; j < m; j++) {    // 가로 방향으로
                    // 이 칸이 그림이 아니거나(0), 이미 방문했다면 스킵
                    if (board[i][j] == 0 || vis[i][j]) continue;
    
                    // 여기까지 왔다는 건 => 새 그림의 "시작점" 발견
                    num++; // 그림 개수 +1
    
    ```
    
    1. 상하좌우로 연결된 그림의 크기를 알아내기 
    
    시작점 좌표를 큐에 넣고 방문 표시
    
    큐에서 원소를 하나 꺼낸다(front pop).
    
    꺼낸 좌표의 4방향을 확인한다.
    
    범위 안에 있고, 아직 방문하지 않았다면
    
    - 방문 표시를 하고
    - 큐에 넣는다(enqueue).
    
    큐가 빌 때까지 2~4를 반복한다.
    
    ```java
    								Queue<int[]> Q = new LinkedList<>();
                    vis[i][j] = true;           // 시작점 방문 표시
                    Q.offer(new int[]{i, j});   // 큐에 시작점 추가
    
                    int area = 0; // 현재 그림의 넓이(칸 수)
    
                    while (!Q.isEmpty()) {
                        // 큐에서 하나 꺼낼 때마다 넓이 +1
                        area++;
                        int[] cur = Q.poll(); // front 원소 꺼내기
                        int x = cur[0], y = cur[1];
    
                        // 현재 좌표에서 상하좌우 4방향 검사
                        for (int dir = 0; dir < 4; dir++) {
                            int nx = x + dx[dir];
                            int ny = y + dy[dir];
    
                            // 1) 범위 밖이면 건너뜀
                            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                            // 2) 이미 방문했거나 그림이 아니면 건너뜀
                            if (vis[nx][ny] || board[nx][ny] != 1) continue;
    
                            // 3) 방문 표시 후 큐에 추가
                            vis[nx][ny] = true;
                            Q.offer(new int[]{nx, ny});
                        }
                    }
                    // BFS가 끝났으니 현재 그림 넓이(area)가 완성됨
                    // 최대 넓이(mx) 갱신
                    mx = Math.max(mx, area);
                }
            }
    ```
    
    1. 출력
        
        ```java
         // 출력: 그림 개수, 가장 큰 그림 넓이
                System.out.println(num);
                System.out.println(mx);
            }
        }
        ```
        
- 문제를 풀면서 이해한 bfs는…
    
    시작점을 큐에 넣고
    
    큐에서 하나씩 꺼내면서 상하좌우로 인접한 칸을 탐색하며
    
    조건을 만족하는 칸을 큐에 또 추가한다….
    
    이중 for문을 돌면서 (board[r][c] == 1 && !visited[r][c]) 인 칸에서 bfs을 시작하면 
    
    해당칸을 포함한 하나의 그림 전체를 탐색하고 크기 구할 수 있다
    
    이과정을 반복하면 도화지에 있는 모든 그림과 그 크기를 알 수 있다.
    
- 다음에 bfs문제를 마주했다면,..
    
    이렇게 풀기
    
    시작점 큐에 넣고 방문 표시
    
    큐가 빌 때까지
    
    - 하나 꺼냄 → 상하좌우(또는 인접 노드) 확인
    - 조건(범위·방문X·유효) 만족 시 큐에 넣고 방문 표시
    
    문제 요구에 맞게 pop 횟수·거리·그룹 수 계산
